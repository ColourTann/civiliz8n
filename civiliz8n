#consts and aliases
	:const startX 22
	:const fiddlyStartX 21 #startX-1
	:const fiddlyEndX 117 #fiddlyStartX + 9 * 11 - 3
	:const fiddlyBotY 60 #startY + 8 * 7
	:const centerX 66
	:const centerY 29
	:const startY 4

	:const choiceStartX 3
	:const choiceTextX 254
	:const choiceTextY 252
	:const choiceStartY 28
	:const choiceGap 12

	#states
	:const state_drawing 0
	:const state_waitingForInput 1
	:const state_incorrectInput 2


	:alias keyPressed v0
	:alias splitX v0
	:alias splitY v1
	:alias xySplit v3
	:alias surroundCheck v5
	:alias surroundTile v6
	:alias surroundIndex v7
	:alias hexPosition3 v8
	:alias hexPosition3 v8
	:alias hexPosition2 v9
	:alias hexPosition va
	:alias drawX vb
	:alias drawY vc
	:alias gameState vd
		
# extra registers
	
	: splitPositions
	0x00
	0x00	

	: selectedTileIndex
	0x00

	: currentTile
	0x00

	: tileTypes
	0x00
	0x00
	0x00

: tileStorage
	# I know I'm tossing like 200 bytes away here but I'm feeling lazy so what can you do?
	# check out the sweet PARALLELOGRAM in the middle! That's the only bit that matters
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 

#text
	: textq
	0xc 0x12 0x12 0x16 0xe 
	: textw
	0x21 0x21 0x21 0x2d 0x12 
	: texte
	0xe 0x10 0x1c 0x10 0xe 
	: textd
	0x1c 0x12 0x12 0x12 0x1c 
	: texts
	0xe 0x10 0xc 0x2 0x1c 
	: texta
	0xc 0x12 0x1e 0x12 0x12 
	: text1
	0x4 0xc 0x4 0x4 0xe 
	: text2
	0xc 0x12 0x4 0x8 0x1e 
	: text3
	0x1c 0x2 0xc 0x2 0x1c 
	: text4
	0x10 0x14 0x14 0xe 0x4 
	: text5
	0x1e 0x10 0xc 0x2 0x1c 
	: text6
	0xe 0x10 0x1c 0x12 0xc 
	: text7
	0x1e 0x2 0x4 0x8 0x10 
	: text8
	0xc 0x12 0xc 0x12 0xc 
	: text9
	0xc 0x12 0xe 0x2 0xc 
	: text0
	0xc 0x12 0x12 0x12 0xc 

#tiles#
	
	#00 is darkblue
	#01 is green
	#10 is brown
	#11 is sand


	: trees
		0x0 0xc 0x3 0x23 0x7f 0x38 0x18 0xf 
		0x0 0xf 0x1e 0x3e 0x77 0x37 0x1f 0xd 
		0x0 0x40 0xc0 0xfc 0x8e 0x8c 0xf8 0xf0 
		0x0 0xf0 0xf8 0xec 0xfe 0xfc 0xd8 0xd0 	

	: hut
		0x0 0xf 0x1f 0x3f 0x7f 0x3e 0x1e 0xf 
		0x0 0xf 0x18 0x30 0x70 0x38 0x18 0xf 
		0x0 0xf0 0xf8 0xfc 0xfe 0x7c 0x78 0xf0 
		0x0 0xf0 0x18 0xc 0xe 0x1c 0x18 0xf0 

	: shrine
		0x0 0xf 0x1c 0x38 0x79 0x38 0x18 0xf 
		0x0 0xf 0x1c 0x39 0x7b 0x39 0x18 0xf 
		0x0 0xf0 0x38 0x1c 0x9e 0x1c 0x18 0xf0  
		0x0 0xf0 0x38 0x9c 0xde 0x9c 0x18 0xf0  


#setup grid stuff#

	: all_of_border_except_bottom_row
	0xf 0x10 0x20 0x40 0x80 0x40 0x20 0x10 0xf0 0x8 0x4 0x2 0x1 0x2 0x4 0x8 

	: bord_left 
	0b00011111		
	0b00100000
	0b01000000
	0b10000000

	: bord_right
	0b11100000
	0b00010000
	0b00001000
	0b00000100

	: bord_x_left
	0b10000000
	0b01000000
	0b00100000
	0b00010000

	: bord_x_right
	0b00000001
	0b00000010
	0b00000100
	0b00001000

	: bord_x_bot	
	0b11111111

: drawOutlines
	drawX := startX 
	drawY := startY

	: drawTops
		loop
			#draw top of hexagon split up into two parts
			i  := bord_left
			sprite drawX drawY 4
			drawX += 8
			i  := bord_right 	
			sprite drawX drawY 4
			drawX += 248		
			drawY += 8
			if drawY < 60 then 
		again
			
		drawX += 11
		v0 := 56
		drawY -= v0
		if drawY == startY begin
			drawY := startY
			drawY += 4
		else 
			drawY := startY
		end
		if drawX < 118 begin
			drawTops	
			return
		end
		
		#draw fiddly bits

		#fiddly lr bits
		drawY := startY
		drawY += 4
		loop
			i := bord_x_left
			drawX := fiddlyStartX
			sprite drawX drawY 4

			i := bord_x_right
			drawX := fiddlyEndX
			sprite drawX drawY 4
			
			drawY += 8		
		if drawY < 60 then again

		#fiddly bot bits
		drawY := fiddlyBotY
		drawX := fiddlyStartX
		drawX += 4
		loop
			i := bord_x_bot
			sprite drawX drawY 1		
			drawX += 22		
		if drawX < 115 then again

		drawPickers

		i := tileTypes
		v0 := 0
		v1 := 1
		v2 := 2
		save v2

		fillPickers


		plane 1
		v0 := 0
		drawPickerText
		v0 := 1
		drawPickerText
		v0 := 2
		drawPickerText

		return

	: drawPickers
		
		drawX := choiceStartX
		drawY := choiceStartY

		loop

			drawX := choiceStartX
			i := all_of_border_except_bottom_row
			sprite drawX drawY 8
			drawX += 8
			v0 := 8
			i += v0
			sprite drawX drawY 8
			drawX += 252
			drawY += 8
			i := bord_x_bot
			sprite drawX drawY 1
			drawY += 248
			drawY += choiceGap

		if drawY < 60 then again

		return

	: fillPickers
		drawX := choiceStartX
		drawY := choiceStartY
		v1 := 0
		loop
			i := tileTypes
			i += v1
			load v0
			if v0 == 0 then i := hut
			if v0 == 1 then i := trees
			if v0 == 2 then i := shrine

			drawX := choiceStartX

			drawHex
			drawY += choiceGap
			v1 += 1
		if drawY < 60 then again
		return


	: drawPickerText
		drawX := choiceTextX
		drawY := choiceStartY
		v1 := choiceTextY
		drawY += v1
		i := text1
		if v0 > 0 begin
			loop
				v1 := 5
				i += v1
				drawY += choiceGap
				v0 += 255
			if v0 > 0 then again
		end

		
		
		
		sprite drawX drawY 5
		drawY += choiceGap

		
		return	

: fillCurrentHex

	# currentTile holds the tile Position
	i := currentTile
	load v0
	hexPosition := v0

	# save 1 in tileStorage to keep track of the fact this tile has been used
	i := tileStorage
	i += v0
	v0 := 1
	save v0

	# get the screen position
	xySplit := hexPosition
	splitByteToXY
	setDrawPositionsFromXY

	drawX += 255
	drawY += 255
	
	i := selectedTileIndex
	load v0
	if v0 == 0 then i := hut
	if v0 == 1 then i := trees
	if v0 == 2 then i := shrine

	drawHex

	return

: drawHex



	# have do 4 draw calls, 2 with each bitplane

	v2 := 8
	plane 1
	sprite drawX drawY 8
	plane 2
	i += v2
	sprite drawX drawY 8
	i += v2
	drawX += 8
	plane 1
	sprite drawX drawY 8
	i += v2
	plane 2
	sprite drawX drawY 8

	return

: nextSurroundingByte
		
	# keep track of surroundIndex so you can get the next tile around easily

	surroundTile := surroundCheck
	if surroundIndex == 0 begin
		surroundTile += 0b11110000
	end
	if surroundIndex == 1 begin
		surroundTile += 255
	end
	if surroundIndex == 2 begin
		surroundTile += 255
		surroundTile += 0b00010000
	end
	if surroundIndex == 3 begin
		surroundTile += 0b00010000
	end
	if surroundIndex == 4 begin
		surroundTile += 1
	end
	if surroundIndex == 5 begin
		surroundTile += 1
		surroundTile += 0b11110000
	end
	surroundIndex += 1
	return
	
: splitByteToXY

	# tile locations encode x/y positions in one byte
	# this splits it into x/y and saves that to splitPositions

	# x portion
	v0 := xySplit
	v2 := 0b11110000
	v0 &= v2
	v0 >>= v0
	v0 >>= v0
	v0 >>= v0
	v0 >>= v0

	# y portion
	v1 := xySplit
	v2 := 0b00001111
	v1 &= v2
	
	# offset so the center is 0,0 ish
	v2 := 8
	v0 -= v2
	v1 -= v2

	i := splitPositions
	save v1
	return

: setDrawPositionsFromXY

	# convenience function to convert grid coordinates into screen coordinates
	drawX := centerX
	drawY := centerY
	i := splitPositions
	load v1
	# must be a better way than having two loops for negative/positive
	if splitX < 150 begin 
		loop
			while splitX != 0 
			splitX += 255
			drawX += 11
			drawY += 4
		again
	end
	if splitX > 150 begin 
		loop
			while splitX != 0 
			splitX += 1
			drawX += 245
			drawY += 252
		again
	end

	if splitY < 150 begin
		loop
			while splitY != 0 
			splitY += 255
			drawY += 8
		again
	end

	if splitY > 150 begin
		loop
			while splitY != 0 
			splitY += 1
			drawY += 248
		again
	end
	return

: drawControls
	
	# draws controls in surrounding tiles
	plane 1
	surroundIndex := 0
	surroundCheck := hexPosition
	loop
		nextSurroundingByte
		hexPosition2 := surroundTile
		getHexType
		if v0 == 0xff begin
			# skips occupied tiles
		 	skipControlDraw
		 	return
		end
		if v0 == 1 begin
			# skips occupied tiles
		 	skipControlDraw
		 	return
		end

		xySplit := surroundTile
		splitByteToXY
		setDrawPositionsFromXY
		i := textq
		v0 := surroundIndex
		v0 += 255
		i += v0
		i += v0
		i += v0
		i += v0
		i += v0
		drawX += 2
		drawY += 1
		sprite drawX drawY 5
		: skipControlDraw
	if surroundIndex < 6 then again
	return

: keyInput	
	
	gameState := state_waitingForInput

	# Watch out, keyPressed is v0 so it won't stick around.
	keyPressed := key

	# selecting a tile to place
	if keyPressed <= 3 begin

		gameState := state_incorrectInput

		if keyPressed == 0 then return


		# fiddly business
		keyPressed += 255
		v1 := keyPressed
		i := selectedTileIndex
		load v0
		if v0 == v1 then return # pressed the same key again
		v2 := v0
		v0 := v1

		# save the new selected index
		i := selectedTileIndex
		save v0

		# erase the current selection
		v0 := v2
		if v0 < 3 begin
			plane 2
			drawPickerText	
		end

		# draw the new selection
		i := selectedTileIndex 
		load v0
		plane 2
		drawPickerText
		return
	end

	v1 := 0xff

	if keyPressed == 4 then v1 := 0
	if keyPressed == 5 then v1 := 1
	if keyPressed == 6 then v1 := 2
	if keyPressed == 9 then v1 := 3
	if keyPressed == 8 then v1 := 4
	if keyPressed == 7 then v1 := 5

	if keyPressed == 0xff begin
		gameState := state_incorrectInput
		return
	end

	# use the surrounding function with the correct index to get the specified tile
	surroundIndex := v1
	surroundCheck := hexPosition
	nextSurroundingByte
	
	# this bit stinks
	hexPosition2 := surroundTile
	hexPosition3 := surroundTile
	getHexType
	
	# should change this to a gameState register
	if v0 != 0 begin 
		gameState := state_incorrectInput
		return
	end


	# if the key is valid, undraw the controls
	drawControls

	# update the currentTile and draw it
	v0 := hexPosition3
	i := currentTile
	save v0



	fillCurrentHex
	return

: getHexType
	# all hex types are stored in storage
	i := tileStorage
	i += hexPosition2
	v0 := 1
	load v0
	return

: main
	hires
	gameState := state_drawing
	drawOutlines 

	plane 2
	v1 := 0
	drawPickerText	



	v0 := 0b10001000
	i := currentTile
	save v0



	# draw starting hex
	fillCurrentHex


	: turn
	loop
		if gameState != state_incorrectInput then drawControls
		keyInput
	again

