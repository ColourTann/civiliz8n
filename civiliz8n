#consts and aliases
	:const startX 22
	:const fiddlyStartX 21 #startX-1
	:const fiddlyEndX 117 #fiddlyStartX + 9 * 11 - 3
	:const fiddlyBotY 60 #startY + 8 * 7
	:const centerX 66
	:const centerY 29
	:const startY 4

	:const choiceStartX 3
	:const choiceTextX 254
	:const choiceTextY 252
	:const choiceStartY 28
	:const choiceGap 12

	#states
	:const state_drawing 0
	:const state_waitingForInput 1
	:const state_incorrectInput 2


	:alias keyPressed v0
	:alias splitX v0
	:alias splitY v1
	:alias xySplit v3
	:alias surroundCheck v5
	:alias surroundTile v6
	:alias surroundIndex v7
	:alias hexPosition3 v8
	:alias hexPosition2 v9
	:alias hexPosition va
	:alias drawX vb
	:alias drawY vc
	:alias gameState vd
		
# extra registers
	
	: splitPositions
	0x00
	0x00	

	: currentTile
	0b00000000

: tileStorage
	# I know I'm tossing like 200 bytes away here but I'm feeling lazy so what can you do?
	# check out the sweet PARALLELOGRAM in the middle! That's the only bit that matters
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 
	0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff 

#text
	: textq
	0xc 0x12 0x12 0x16 0xe 
	: textw
	0x21 0x21 0x21 0x2d 0x12 
	: texte
	0xe 0x10 0x1c 0x10 0xe 
	: textd
	0x1c 0x12 0x12 0x12 0x1c 
	: texts
	0xe 0x10 0xc 0x2 0x1c 
	: texta
	0xc 0x12 0x1e 0x12 0x12 
	: text1
	0x4 0xc 0x4 0x4 0xe 
	: text2
	0xc 0x12 0x4 0x8 0x1e 
	: text3
	0x1c 0x2 0xc 0x2 0x1c 
	: text4
	0x10 0x14 0x14 0xe 0x4 
	: text5
	0x1e 0x10 0xc 0x2 0x1c 
	: text6
	0xe 0x10 0x1c 0x12 0xc 
	: text7
	0x1e 0x2 0x4 0x8 0x10 
	: text8
	0xc 0x12 0xc 0x12 0xc 
	: text9
	0xc 0x12 0xe 0x2 0xc 
	: text0
	0xc 0x12 0x12 0x12 0xc 

#tiles#
	
	#00 is darkblue
	#01 is green
	#10 is brown
	#11 is sand


	: trees
	0b00000000			
	0b00000100
	0b00000100
	0b00000000
	0b00010000
	0b00010001
	0b00000001

	0b00001110			
	0b00000000
	0b00111000
	0b00111011
	0b00000011
	0b00000000
	0b00000000

	0b00000000			
	0b00000000
	0b00000000
	0b00100000
	0b00100000
	0b00000000
	0b00000000

	0b00000000			
	0b01110000
	0b01110000
	0b10000000
	0b10000000
	0b00000000
	0b00000000

#setup grid stuff#

	: all_of_border_except_bottom_row
	0xf 0x10 0x20 0x40 0x80 0x40 0x20 0x10 0xf0 0x8 0x4 0x2 0x1 0x2 0x4 0x8 

	: bord_left 
	0b00011111		
	0b00100000
	0b01000000
	0b10000000

	: bord_right
	0b11100000
	0b00010000
	0b00001000
	0b00000100

	: bord_x_left
	0b10000000
	0b01000000
	0b00100000
	0b00010000

	: bord_x_right
	0b00000001
	0b00000010
	0b00000100
	0b00001000

	: bord_x_bot	
	0b11111111

: drawOutlines
	drawX := startX 
	drawY := startY

	: drawTops
		loop
			#draw top of hexagon split up into two parts
			i  := bord_left
			sprite drawX drawY 4
			drawX += 8
			i  := bord_right 	
			sprite drawX drawY 4
			drawX += 248		
			drawY += 8
			if drawY < 60 then 
		again
			
		drawX += 11
		v0 := 56
		drawY -= v0
		if drawY == startY begin
			drawY := startY
			drawY += 4
		else 
			drawY := startY
		end
		if drawX < 118 begin
			drawTops	
			return
		end
		
		#draw fiddly bits

		#fiddly lr bits
		drawY := startY
		drawY += 4
		loop
			i := bord_x_left
			drawX := fiddlyStartX
			sprite drawX drawY 4

			i := bord_x_right
			drawX := fiddlyEndX
			sprite drawX drawY 4
			
			drawY += 8		
		if drawY < 60 then again

		#fiddly bot bits
		drawY := fiddlyBotY
		drawX := fiddlyStartX
		drawX += 4
		loop
			i := bord_x_bot
			sprite drawX drawY 1		
			drawX += 22		
		if drawX < 115 then again

		drawPickers
		drawPickerText

		return

	: drawPickers
		
		drawX := choiceStartX
		drawY := choiceStartY

	

		loop

			drawX := choiceStartX
			i := all_of_border_except_bottom_row
			sprite drawX drawY 8
			drawX += 8
			v0 := 8
			i += v0
			sprite drawX drawY 8
			drawX += 252
			drawY += 8
			i := bord_x_bot
			sprite drawX drawY 1
			drawY += 248
			drawY += choiceGap
		if drawY < 60 then again
		return

	: drawPickerText
	
		drawY := choiceStartY
		v0 := choiceTextY
		drawY += v0
		v1 := 0
		loop
			drawX := choiceTextX
			i := text1
			i += v1
			i += v1
			i += v1
			i += v1
			i += v1
			sprite drawX drawY 5
			drawY += choiceGap
			v1 += 1
		if drawY < 60 then again
		return

	

: drawHex

	# currentTile holds the tile Position
	i := currentTile
	load v0
	hexPosition := v0

	# save 1 in tileStorage to keep track of the fact this tile has been used
	i := tileStorage
	i += v0
	v0 := 1
	save v0

	# get the screen position
	xySplit := hexPosition
	splitByteToXY
	setDrawPositionsFromXY

	# have do 4 draw calls, 2 with each bitplane
	i := trees
	v2 := 7
	plane 1
	sprite drawX drawY 7
	plane 2
	i += v2
	sprite drawX drawY 7
	i += v2
	drawX += 8
	plane 1
	sprite drawX drawY 7
	i += v2
	plane 2
	sprite drawX drawY 7

	return

: nextSurroundingByte
		
	# keep track of surroundIndex so you can get the next tile around easily

	surroundTile := surroundCheck
	if surroundIndex == 0 begin
		surroundTile += 0b11110000
	end
	if surroundIndex == 1 begin
		surroundTile += 255
	end
	if surroundIndex == 2 begin
		surroundTile += 255
		surroundTile += 0b00010000
	end
	if surroundIndex == 3 begin
		surroundTile += 0b00010000
	end
	if surroundIndex == 4 begin
		surroundTile += 1
	end
	if surroundIndex == 5 begin
		surroundTile += 1
		surroundTile += 0b11110000
	end
	surroundIndex += 1
	return
	
: splitByteToXY

	# tile locations encode x/y positions in one byte
	# this splits it into x/y and saves that to splitPositions

	# x portion
	v0 := xySplit
	v2 := 0b11110000
	v0 &= v2
	v0 >>= v0
	v0 >>= v0
	v0 >>= v0
	v0 >>= v0

	# y portion
	v1 := xySplit
	v2 := 0b00001111
	v1 &= v2
	
	# offset so the center is 0,0 ish
	v2 := 8
	v0 -= v2
	v1 -= v2

	i := splitPositions
	save v1
	return

: setDrawPositionsFromXY

	# convenience function to convert grid coordinates into screen coordinates
	drawX := centerX
	drawY := centerY
	i := splitPositions
	load v1
	# must be a better way than having two loops for negative/positive
	if splitX < 150 begin 
		loop
			while splitX != 0 
			splitX += 255
			drawX += 11
			drawY += 4
		again
	end
	if splitX > 150 begin 
		loop
			while splitX != 0 
			splitX += 1
			drawX += 245
			drawY += 252
		again
	end

	if splitY < 150 begin
		loop
			while splitY != 0 
			splitY += 255
			drawY += 8
		again
	end

	if splitY > 150 begin
		loop
			while splitY != 0 
			splitY += 1
			drawY += 248
		again
	end
	return

: drawControls
	
	# draws controls in surrounding tiles
	plane 1
	surroundIndex := 0
	surroundCheck := hexPosition
	loop
		nextSurroundingByte
		hexPosition2 := surroundTile
		getHexType
		if v0 == 0xff begin
			# skips occupied tiles
		 	skipControlDraw
		 	return
		end
		if v0 == 1 begin
			# skips occupied tiles
		 	skipControlDraw
		 	return
		end

		xySplit := surroundTile
		splitByteToXY
		setDrawPositionsFromXY
		i := textq
		v0 := surroundIndex
		v0 += 255
		i += v0
		i += v0
		i += v0
		i += v0
		i += v0
		drawX += 2
		drawY += 1
		sprite drawX drawY 5
		: skipControlDraw
	if surroundIndex < 6 then again
	return

: keyInput	
	
	gameState := state_waitingForInput

	# Watch out, keyPressed is v0 so it won't stick around.
	keyPressed := key
	if keyPressed == 4 then v1 := 0
	if keyPressed == 5 then v1 := 1
	if keyPressed == 6 then v1 := 2
	if keyPressed == 9 then v1 := 3
	if keyPressed == 8 then v1 := 4
	if keyPressed == 7 then v1 := 5

	# use the surrounding function with the correct index to get the specified tile
	surroundIndex := v1
	surroundCheck := hexPosition
	nextSurroundingByte
	
	# this bit stinks
	hexPosition2 := surroundTile
	hexPosition3 := surroundTile
	getHexType
	
	# should change this to a gameState register
	if v0 != 0 begin 
		gameState := state_incorrectInput
		return
	end


	# if the key is valid, undraw the controls
	drawControls

	# update the currentTile and draw it
	v0 := hexPosition3
	i := currentTile
	save v0
	drawHex
	return

: getHexType
	# all hex types are stored in storage
	i := tileStorage
	i += hexPosition2
	v0 := 1
	load v0
	return

: main
	hires
	gameState := state_drawing
	drawOutlines 
	v0 := 0b10001000
	i := currentTile
	save v0
	drawHex

	

	: turn
	loop
		if gameState != state_incorrectInput then drawControls
		keyInput
	again
	


	



			
	
	


